<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/TODO.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/TODO.md" />
              <option name="originalContent" value="&#10;# BookBuddy Master Plan&#10;&#10;This document outlines the development roadmap for BookBuddy, a mobile application for managing and reading books.&#10;&#10;## App Description&#10;&#10;BookBuddy allows users to:&#10;&#10;*   Organize their personal library of books.&#10;*   Import books from PDF and EPUB files.&#10;*   Extract text from images using OCR technology.&#10;*   Read books in a dedicated reader interface.&#10;*   Generate AI-powered summaries of their books.&#10;*   Create PDF files from pictures.&#10;*   Listen to books using text-to-speech (TTS).&#10;*   Translate books with various integrated services.&#10;*   Share their own books and download books created by other users.&#10;*   Connect with friends and get updates on their new book publications.&#10;&#10;## High-Level Goals&#10;&#10;1.  **Our Guiding Principle: Empower the Journey of Knowledge.** We recognize that roles like Reader, Writer, Translator, Student, Teacher, and Researcher are not static professions but fluid states in the universal human journey of learning and creating. All architectural decisions must empower this journey, making knowledge accessible and its expression effortless through a robust, user-friendly system.&#10;2.  **Modernize the UI:** Migrate the existing UI from XML layouts to Jetpack Compose for a more declarative and maintainable codebase.&#10;3.  **Improve Performance:** Optimize the app's performance, particularly in the areas of PDF processing and OCR.&#10;4.  **Enhance User Experience:** Add new features and refine existing ones to create a more intuitive and engaging user experience.&#10;5.  **Increase Test Coverage:** Write comprehensive unit and integration tests to ensure the app's stability and reliability.&#10;6.  **Integrate AI &amp; Advanced Content Features:** Add capabilities like summarization, TTS, and multi-option translation.&#10;7.  **Build an Online Community:** Create a platform for users to share and discover books.&#10;8.  **Empower Creators:** Provide tools for authors to create, publish, and monetize their work within the BookBuddy ecosystem.&#10;9.  **Break Language Barriers:** Enable users to read, translate, and publish books across any language, fostering a global literary community.&#10;&#10;## Detailed Roadmap&#10;&#10;### Phase 1: Foundational Improvements&#10;&#10;*   **Update Dependencies:**&#10;    *   [X] Upgrade all libraries to their latest stable versions.&#10;    *   [X] Replace deprecated libraries with modern alternatives.&#10;*   **Refactor to Kotlin:**&#10;    *   [X] Convert all existing Java code to Kotlin to take advantage of its modern features and improved syntax.&#10;*   **Introduce Jetpack Compose:**&#10;    *   [X] Migrate the `MainActivity` to Jetpack Compose.&#10;    *   [X] Gradually migrate other screens to Compose, starting with the simpler ones like `SettingsActivity`.&#10;&#10;### Phase 2: UI/UX Enhancements&#10;&#10;*   **Redesign the Library:**&#10;    *   [X] Implement a more visually appealing and user-friendly design for the `LibraryActivity`.&#10;    *   [X] Add options for sorting and filtering the user's book collection.&#10;*   **Improve the Reader:**&#10;    *   [X] Enhance the `ReaderActivity` with features like adjustable font sizes, themes, and bookmarks.&#10;    *   [X] Add support for more file formats, such as EPUB.&#10;*   **Architect for Performance and Scale:**&#10;    *   [X] Re-architect file processing to save books as a directory of individual page files.&#10;    *   [X] Update the `ReaderActivity` to load only the current page's text into memory on demand.&#10;&#10;### Phase 3: New Features&#10;&#10;*   **Online Community Platform:**&#10;    *   [ ] Design and implement a backend service for user authentication and book storage.&#10;    *   [ ] Create a UI for users to upload their books to the online database.&#10;    *   [ ] Develop a browsable and searchable public library of user-created books.&#10;    *   [ ] Implement a system for users to download books from the public library to their personal library.&#10;    *   [ ] Implement a friend request system allowing users to connect with each other.&#10;    *   [ ] Create a notification feed or system to inform users about new books published by their friends.&#10;    *   [ ] Add support for publishing user-created translations of books, with clear attribution to the original author and the translator.&#10;*   **Authoring &amp; Publishing Tools:**&#10;    *   [X] Implement a &quot;draft&quot; status for books in the library.&#10;    *   [X] The editor will have a dirty-state check to manage when saving is needed.&#10;    *   [X] Implement a robust auto-save mechanism that works in the background.&#10;    *   [X] The &quot;Save&quot; button in the editor will manually trigger a save and clear the dirty state.&#10;    *   [X] Design and implement a high-performance, intuitive editor focused on a fast and fluid writing experience, regardless of document size.&#10;    *   [X] Implement a comprehensive set of rich text formatting tools (e.g., bold, italics, headings, lists).&#10;    *   [X] Add &quot;Create New Book&quot; feature to write books from scratch with title, author, and language selection.&#10;    *   [ ] Create a dedicated &quot;Translation Mode&quot; within the editor for side-by-side translation work.&#10;    *   [ ] Add a &quot;Save to Library&quot; feature to permanently store both new creations and edited translations.&#10;*   **Book Marketplace &amp; Monetization:**&#10;    *   [ ] Implement a system for authors to set a price for their books or offer them for free.&#10;    *   [ ] Integrate a secure payment gateway for book sales.&#10;    *   [ ] Develop a &quot;My Earnings&quot; dashboard for authors to track sales.&#10;*   **Language &amp; Translation Hub:**&#10;    *   [X] Design and implement a centralized Language Management screen.&#10;    *   [ ] Create sub-sections within the hub for managing different language resources:&#10;        *   **Text-to-Speech (TTS):**&#10;            *   [X] Allow users to select their preferred system TTS Engine (Google, Samsung, etc.).&#10;            *   [X] Display all available languages for the selected engine and their installation status.&#10;            *   [X] Guide users to the system settings to download missing voice packs.&#10;        *   **Text Recognition (OCR):**&#10;            *   [ ] Display all available ML Kit OCR language packs (e.g., Devanagari, Latin, Chinese).&#10;            *   [ ] Show their download status.&#10;            *   [ ] Allow users to trigger downloads for new OCR models directly from within the app.&#10;        *   **Translation:**&#10;            *   [ ] Display all available offline translation models.&#10;            *   [ ] Show their download status.&#10;            *   [ ] Allow users to trigger downloads for new translation models.&#10;*   **Advanced OCR:**&#10;    *   [X] Explore more advanced OCR techniques to improve the accuracy of text extraction.&#10;    *   [ ] Implement multi-language detection, including mixed languages on a single page.&#10;*   **AI-Powered Summarization:**&#10;    *   [ ] Implement a feature to generate summaries of books using an AI model.&#10;*   **Image-to-PDF Creation:**&#10;    *   [ ] Develop a feature to capture or select multiple images and compile them into a single PDF file.&#10;*   **Audiobook &amp; Text-to-Speech:**&#10;    *   [ ] Implement on-the-fly language detection for on-screen text to automatically select the correct TTS voice.&#10;    *   [ ] Redesign the reader's audio controls to offer two distinct options: &quot;Hear Original Text&quot; and &quot;Hear Translated Text&quot;.&#10;    *   [X] Integrate a TTS engine that can be configured by user preferences (e.g., Google vs. Samsung).&#10;&#10;### Phase 4: Testing and Release&#10;&#10;*   **Write Unit Tests:**&#10;    *   [ ] Write comprehensive unit tests for all major components of the app.&#10;*   **Conduct User Testing:**&#10;    *   [ ] Gather feedback from a group of beta testers to identify and address any usability issues.&#10;*   **Prepare for Release:**&#10;    *   [ ] Finalize the app's branding and marketing materials.&#10;    *   [ ] Publish the app to the Google Play Store.&#10;&#10;## Changelog&#10;&#10;### Dependencies &amp; Architecture&#10;*   Upgraded all project dependencies to latest stable versions (AppCompat 1.7.1, Material 1.13.0, ConstraintLayout 2.2.1, etc.)&#10;*   Converted entire codebase from Java to Kotlin&#10;*   Migrated UI from XML layouts to Jetpack Compose (MainActivity, SettingsActivity, LibraryActivity)&#10;*   Re-architected file processing to paged-file system for performance and crash prevention with large books&#10;&#10;### Features &amp; Enhancements&#10;*   **Library**: Added sorting/filtering options, grid layout with book covers, &quot;Draft&quot; badge for in-progress books&#10;*   **Reader**: Font size adjustment, theme selection (light/dark), EPUB support, TTS with voice selection&#10;*   **OCR**: Improved PDF accuracy (300 DPI rendering), added Bangla support via Devanagari ML Kit&#10;*   **Language Management**: TTS engine selection screen showing all available voices and installation status&#10;*   **Create New Book**: FloatingActionButton in library to write from scratch with metadata input&#10;&#10;### Professional Authoring System&#10;*   **Editor**: High-performance Quill.js WebView with rich text formatting toolbar (bold, italic, headings, lists, colors, alignment, etc.)&#10;*   **Multi-page System**: Flexible page numbering (1, 1.1, 1.2, 2, 2.1) allowing page insertion anywhere; navigation with Previous/Next/Jump controls&#10;*   **Page Management**: 3 buttons - &quot;Before&quot; (insert before current), &quot;After&quot; (insert after current), &quot;At End&quot; (append new page)&#10;*   **Auto-save**: Silent 10-second auto-save to `.draft.txt` files; manual Publish commits to library&#10;*   **Export System**: 3 formats - Plain Text (.txt), Markdown (.md), Clean HTML (.html) - removes Quill markup for publishers/printing&#10;*   **Clean UI**: 3-dot menu for Publish/Export; editor focused on writing with minimal distractions&#10;&#10;### Build Environment&#10;*   Gradle Version: 8.13&#10;" />
              <option name="updatedContent" value="&#10;# BookBuddy Master Plan&#10;&#10;This document outlines the development roadmap for BookBuddy, a mobile application for managing and reading books.&#10;&#10;## App Description&#10;&#10;BookBuddy allows users to:&#10;&#10;*   Organize their personal library of books.&#10;*   Import books from PDF and EPUB files.&#10;*   Extract text from images using OCR technology.&#10;*   Read books in a dedicated reader interface.&#10;*   Generate AI-powered summaries of their books.&#10;*   Create PDF files from pictures.&#10;*   Listen to books using text-to-speech (TTS).&#10;*   Translate books with various integrated services.&#10;*   Share their own books and download books created by other users.&#10;*   Connect with friends and get updates on their new book publications.&#10;&#10;## High-Level Goals&#10;&#10;1.  **Our Guiding Principle: Empower the Journey of Knowledge.** We recognize that roles like Reader, Writer, Translator, Student, Teacher, and Researcher are not static professions but fluid states in the universal human journey of learning and creating. All architectural decisions must empower this journey, making knowledge accessible and its expression effortless through a robust, user-friendly system.&#10;2.  **Modernize the UI:** Migrate the existing UI from XML layouts to Jetpack Compose for a more declarative and maintainable codebase.&#10;3.  **Improve Performance:** Optimize the app's performance, particularly in the areas of PDF processing and OCR.&#10;4.  **Enhance User Experience:** Add new features and refine existing ones to create a more intuitive and engaging user experience.&#10;5.  **Increase Test Coverage:** Write comprehensive unit and integration tests to ensure the app's stability and reliability.&#10;6.  **Integrate AI &amp; Advanced Content Features:** Add capabilities like summarization, TTS, and multi-option translation.&#10;7.  **Build an Online Community:** Create a platform for users to share and discover books.&#10;8.  **Empower Creators:** Provide tools for authors to create, publish, and monetize their work within the BookBuddy ecosystem.&#10;9.  **Break Language Barriers:** Enable users to read, translate, and publish books across any language, fostering a global literary community.&#10;&#10;## Detailed Roadmap&#10;&#10;### Phase 1: Foundational Improvements&#10;&#10;*   **Update Dependencies:**&#10;    *   [X] Upgrade all libraries to their latest stable versions.&#10;    *   [X] Replace deprecated libraries with modern alternatives.&#10;*   **Refactor to Kotlin:**&#10;    *   [X] Convert all existing Java code to Kotlin to take advantage of its modern features and improved syntax.&#10;*   **Introduce Jetpack Compose:**&#10;    *   [X] Migrate the `MainActivity` to Jetpack Compose.&#10;    *   [X] Gradually migrate other screens to Compose, starting with the simpler ones like `SettingsActivity`.&#10;&#10;### Phase 2: UI/UX Enhancements&#10;&#10;*   **Redesign the Library:**&#10;    *   [X] Implement a more visually appealing and user-friendly design for the `LibraryActivity`.&#10;    *   [X] Add options for sorting and filtering the user's book collection.&#10;*   **Improve the Reader:**&#10;    *   [X] Enhance the `ReaderActivity` with features like adjustable font sizes, themes, and bookmarks.&#10;    *   [X] Add support for more file formats, such as EPUB.&#10;*   **Architect for Performance and Scale:**&#10;    *   [X] Re-architect file processing to save books as a directory of individual page files.&#10;    *   [X] Update the `ReaderActivity` to load only the current page's text into memory on demand.&#10;&#10;### Phase 3: New Features&#10;&#10;*   **Online Community Platform:**&#10;    *   [ ] Design and implement a backend service for user authentication and book storage.&#10;    *   [ ] Create a UI for users to upload their books to the online database.&#10;    *   [ ] Develop a browsable and searchable public library of user-created books.&#10;    *   [ ] Implement a system for users to download books from the public library to their personal library.&#10;    *   [ ] Implement a friend request system allowing users to connect with each other.&#10;    *   [ ] Create a notification feed or system to inform users about new books published by their friends.&#10;    *   [ ] Add support for publishing user-created translations of books, with clear attribution to the original author and the translator.&#10;*   **Authoring &amp; Publishing Tools:**&#10;    *   [X] Implement a &quot;draft&quot; status for books in the library.&#10;    *   [X] The editor will have a dirty-state check to manage when saving is needed.&#10;    *   [X] Implement a robust auto-save mechanism that works in the background.&#10;    *   [X] The &quot;Save&quot; button in the editor will manually trigger a save and clear the dirty state.&#10;    *   [X] Design and implement a high-performance, intuitive editor focused on a fast and fluid writing experience, regardless of document size.&#10;    *   [X] Implement a comprehensive set of rich text formatting tools (e.g., bold, italics, headings, lists).&#10;    *   [X] Add &quot;Create New Book&quot; feature to write books from scratch with title, author, and language selection.&#10;    *   [ ] Create a dedicated &quot;Translation Mode&quot; within the editor for side-by-side translation work.&#10;    *   [ ] Add a &quot;Save to Library&quot; feature to permanently store both new creations and edited translations.&#10;*   **Book Marketplace &amp; Monetization:**&#10;    *   [ ] Implement a system for authors to set a price for their books or offer them for free.&#10;    *   [ ] Integrate a secure payment gateway for book sales.&#10;    *   [ ] Develop a &quot;My Earnings&quot; dashboard for authors to track sales.&#10;*   **Language &amp; Translation Hub:**&#10;    *   [X] Design and implement a centralized Language Management screen.&#10;    *   [ ] Create sub-sections within the hub for managing different language resources:&#10;        *   **Text-to-Speech (TTS):**&#10;            *   [X] Allow users to select their preferred system TTS Engine (Google, Samsung, etc.).&#10;            *   [X] Display all available languages for the selected engine and their installation status.&#10;            *   [X] Guide users to the system settings to download missing voice packs.&#10;        *   **Text Recognition (OCR):**&#10;            *   [ ] Display all available ML Kit OCR language packs (e.g., Devanagari, Latin, Chinese).&#10;            *   [ ] Show their download status.&#10;            *   [ ] Allow users to trigger downloads for new OCR models directly from within the app.&#10;        *   **Translation:**&#10;            *   [ ] Display all available offline translation models.&#10;            *   [ ] Show their download status.&#10;            *   [ ] Allow users to trigger downloads for new translation models.&#10;*   **Advanced OCR:**&#10;    *   [X] Explore more advanced OCR techniques to improve the accuracy of text extraction.&#10;    *   [ ] Implement multi-language detection, including mixed languages on a single page.&#10;*   **AI-Powered Summarization:**&#10;    *   [ ] Implement a feature to generate summaries of books using an AI model.&#10;*   **Image-to-PDF Creation:**&#10;    *   [ ] Develop a feature to capture or select multiple images and compile them into a single PDF file.&#10;*   **Audiobook &amp; Text-to-Speech:**&#10;    *   [ ] Implement on-the-fly language detection for on-screen text to automatically select the correct TTS voice.&#10;    *   [ ] Redesign the reader's audio controls to offer two distinct options: &quot;Hear Original Text&quot; and &quot;Hear Translated Text&quot;.&#10;    *   [X] Integrate a TTS engine that can be configured by user preferences (e.g., Google vs. Samsung).&#10;&#10;### Phase 4: Testing and Release&#10;&#10;*   **Write Unit Tests:**&#10;    *   [ ] Write comprehensive unit tests for all major components of the app.&#10;*   **Conduct User Testing:**&#10;    *   [ ] Gather feedback from a group of beta testers to identify and address any usability issues.&#10;*   **Prepare for Release:**&#10;    *   [ ] Finalize the app's branding and marketing materials.&#10;    *   [ ] Publish the app to the Google Play Store.&#10;&#10;## Changelog&#10;&#10;### Dependencies &amp; Architecture&#10;*   Upgraded all project dependencies to latest stable versions (AppCompat 1.7.1, Material 1.13.0, ConstraintLayout 2.2.1, etc.)&#10;*   Converted entire codebase from Java to Kotlin&#10;*   Migrated UI from XML layouts to Jetpack Compose (MainActivity, SettingsActivity, LibraryActivity)&#10;*   Re-architected file processing to paged-file system for performance and crash prevention with large books&#10;&#10;### Features &amp; Enhancements&#10;*   **Library**: Added sorting/filtering options, grid layout with book covers, &quot;Draft&quot; badge for in-progress books&#10;*   **Reader**: Font size adjustment, theme selection (light/dark), EPUB support, TTS with voice selection&#10;*   **OCR**: Improved PDF accuracy (300 DPI rendering), added Bangla support via Devanagari ML Kit&#10;*   **Language Management**: TTS engine selection screen showing all available voices and installation status&#10;*   **Create New Book**: FloatingActionButton in library to write from scratch with metadata input&#10;&#10;### Professional Authoring System&#10;*   **Editor**: High-performance Quill.js WebView with rich text formatting toolbar (bold, italic, headings, lists, colors, alignment, etc.)&#10;*   **Multi-page System**: Flexible page numbering (1, 1.1, 1.2, 2, 2.1) allowing page insertion anywhere; navigation with Previous/Next/Jump controls&#10;*   **Page Management**: 3 buttons - &quot;Before&quot; (insert before current), &quot;After&quot; (insert after current), &quot;At End&quot; (append new page)&#10;*   **Auto-save**: Silent 10-second auto-save to `.draft.txt` files; manual Publish commits to library&#10;*   **Export System**: 3 formats - Plain Text (.txt), Markdown (.md), Clean HTML (.html) - removes Quill markup for publishers/printing&#10;*   **Clean UI**: 3-dot menu for Publish/Export; editor focused on writing with minimal distractions&#10;*   **Library Refresh**: Fixed library not loading on app start - now properly uses Compose state management with refresh trigger on onResume()&#10;*   **Professional Reader**: New BookReaderActivity for published books - read-only Quill.js display with rich formatting, adjustable font size (12-32pt), minimal UI with 3-dot menu, page navigation identical to editor. Separate from OCR-based ReaderActivity which handles scanned books.&#10;*   **Seamless Edit Flow**: BookReaderActivity includes &quot;Edit&quot; button in 3-dot menu that opens the book in EditorActivity at the exact same page you were reading - smooth transition from reading to editing.&#10;&#10;### Build Environment&#10;*   Gradle Version: 8.13&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;!-- Permissions --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;&#10;    &lt;uses-feature&#10;        android:name=&quot;android.hardware.camera&quot;&#10;        android:required=&quot;true&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.BookBuddy&quot;&#10;        tools:targetApi=&quot;31&quot;&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:theme=&quot;@style/Theme.BookBuddy&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.CameraActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:screenOrientation=&quot;portrait&quot;&#10;            android:theme=&quot;@style/Theme.BookBuddy&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.FileSelectorActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:theme=&quot;@style/Theme.BookBuddy&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.LibraryActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:theme=&quot;@style/Theme.BookBuddy&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.SettingsActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:theme=&quot;@style/Theme.BookBuddy&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.ReaderActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:theme=&quot;@style/Theme.BookBuddy&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.OcrResultActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:theme=&quot;@style/Theme.BookBuddy&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.LanguageActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:theme=&quot;@style/Theme.BookBuddy&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.EditorActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:theme=&quot;@style/Theme.BookBuddy&quot; /&gt;&#10;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;!-- Permissions --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;&#10;    &lt;uses-feature&#10;        android:name=&quot;android.hardware.camera&quot;&#10;        android:required=&quot;true&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.BookBuddy&quot;&#10;        tools:targetApi=&quot;31&quot;&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:theme=&quot;@style/Theme.BookBuddy&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.CameraActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:screenOrientation=&quot;portrait&quot;&#10;            android:theme=&quot;@style/Theme.BookBuddy&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.FileSelectorActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:theme=&quot;@style/Theme.BookBuddy&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.LibraryActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:theme=&quot;@style/Theme.BookBuddy&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.SettingsActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:theme=&quot;@style/Theme.BookBuddy&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.ReaderActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:theme=&quot;@style/Theme.BookBuddy&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.OcrResultActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:theme=&quot;@style/Theme.BookBuddy&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.LanguageActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:theme=&quot;@style/Theme.BookBuddy&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.EditorActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:theme=&quot;@style/Theme.BookBuddy&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.BookReaderActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:theme=&quot;@style/Theme.BookBuddy&quot; /&gt;&#10;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/assets/reader.html">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/assets/reader.html" />
              <option name="updatedContent" value="&lt;!DOCTYPE html&gt;&#10;&lt;html lang=&quot;en&quot;&gt;&#10;&lt;head&gt;&#10;    &lt;meta charset=&quot;UTF-8&quot;&gt;&#10;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;&gt;&#10;    &lt;title&gt;Book Reader&lt;/title&gt;&#10;    &lt;link href=&quot;https://cdn.quilljs.com/1.3.6/quill.snow.css&quot; rel=&quot;stylesheet&quot;&gt;&#10;    &lt;script src=&quot;https://cdn.quilljs.com/1.3.6/quill.js&quot;&gt;&lt;/script&gt;&#10;    &lt;style&gt;&#10;        * {&#10;            margin: 0;&#10;            padding: 0;&#10;            box-sizing: border-box;&#10;        }&#10;&#10;        html, body {&#10;            height: 100%;&#10;            font-family: Georgia, serif;&#10;            background-color: #f9f9f9;&#10;        }&#10;&#10;        #reader-container {&#10;            height: 100%;&#10;            padding: 16px;&#10;            overflow-y: auto;&#10;        }&#10;&#10;        .ql-container {&#10;            border: none !important;&#10;            font-size: 16pt;&#10;            line-height: 1.8;&#10;        }&#10;&#10;        .ql-editor {&#10;            padding: 20px;&#10;            min-height: 100%;&#10;            background-color: white;&#10;            box-shadow: 0 2px 8px rgba(0,0,0,0.1);&#10;            border-radius: 8px;&#10;        }&#10;&#10;        /* Make editor read-only appearance */&#10;        .ql-editor:focus {&#10;            outline: none;&#10;        }&#10;&#10;        /* Hide toolbar - this is read-only */&#10;        .ql-toolbar {&#10;            display: none !important;&#10;        }&#10;&#10;        /* Improve text rendering */&#10;        p {&#10;            margin-bottom: 1em;&#10;        }&#10;&#10;        h1, h2, h3, h4, h5, h6 {&#10;            margin-top: 1.5em;&#10;            margin-bottom: 0.5em;&#10;            font-weight: bold;&#10;        }&#10;&#10;        blockquote {&#10;            border-left: 4px solid #ccc;&#10;            padding-left: 16px;&#10;            color: #666;&#10;            margin: 1em 0;&#10;        }&#10;    &lt;/style&gt;&#10;&lt;/head&gt;&#10;&lt;body&gt;&#10;    &lt;div id=&quot;reader-container&quot;&gt;&#10;        &lt;div id=&quot;editor&quot;&gt;&lt;/div&gt;&#10;    &lt;/div&gt;&#10;&#10;    &lt;script&gt;&#10;        // Initialize Quill in read-only mode&#10;        var quill = new Quill('#editor', {&#10;            theme: 'snow',&#10;            readOnly: true,&#10;            modules: {&#10;                toolbar: false  // No toolbar for reading&#10;            }&#10;        });&#10;&#10;        // Function to set content from native code&#10;        function setContent(htmlContent, fontSize) {&#10;            if (htmlContent) {&#10;                quill.root.innerHTML = htmlContent;&#10;            } else {&#10;                quill.root.innerHTML = '&lt;p&gt;&lt;br&gt;&lt;/p&gt;';&#10;            }&#10;            &#10;            if (fontSize) {&#10;                document.querySelector('.ql-container').style.fontSize = fontSize + 'pt';&#10;            }&#10;        }&#10;&#10;        // Function to update font size&#10;        function setFontSize(size) {&#10;            document.querySelector('.ql-container').style.fontSize = size + 'pt';&#10;        }&#10;&#10;        // Disable editing completely&#10;        quill.enable(false);&#10;    &lt;/script&gt;&#10;&lt;/body&gt;&#10;&lt;/html&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/vuiya/bookbuddy/BookReaderActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/vuiya/bookbuddy/BookReaderActivity.kt" />
              <option name="originalContent" value="&#10;&#10;" />
              <option name="updatedContent" value="package com.vuiya.bookbuddy&#10;&#10;import android.app.Activity&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.ArrowForward&#10;import androidx.compose.material.icons.filled.Edit&#10;import androidx.compose.material.icons.filled.MoreVert&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.unit.dp&#10;import com.vuiya.bookbuddy.ui.theme.BookBuddyTheme&#10;import java.io.File&#10;import android.annotation.SuppressLint&#10;import android.view.ViewGroup&#10;import android.webkit.WebView&#10;import android.webkit.WebViewClient&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;&#10;class BookReaderActivity : ComponentActivity() {&#10;    private lateinit var viewModel: BookReaderViewModel&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        val bookPath = intent.getStringExtra(&quot;book_path&quot;)&#10;        val bookTitle = intent.getStringExtra(&quot;book_title&quot;) ?: &quot;Book&quot;&#10;&#10;        viewModel = BookReaderViewModel(bookPath)&#10;&#10;        setContent {&#10;            BookBuddyTheme {&#10;                BookReaderScreen(&#10;                    bookTitle = bookTitle,&#10;                    viewModel = viewModel&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun BookReaderScreen(bookTitle: String, viewModel: BookReaderViewModel) {&#10;    val activity = (LocalContext.current as? Activity)&#10;    val context = LocalContext.current&#10;    val isLoading = viewModel.isLoading.value&#10;    var showMenu by remember { mutableStateOf(false) }&#10;    var showFontSizeDialog by remember { mutableStateOf(false) }&#10;&#10;    if (showFontSizeDialog) {&#10;        FontSizeDialog(&#10;            currentSize = viewModel.fontSize.value,&#10;            onDismiss = { showFontSizeDialog = false },&#10;            onSizeSelected = { size -&gt;&#10;                viewModel.setFontSize(size)&#10;                showFontSizeDialog = false&#10;            }&#10;        )&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            Column {&#10;                TopAppBar(&#10;                    title = {&#10;                        Text(&#10;                            bookTitle,&#10;                            style = MaterialTheme.typography.headlineSmall&#10;                        )&#10;                    },&#10;                    navigationIcon = {&#10;                        IconButton(onClick = { activity?.finish() }) {&#10;                            Icon(Icons.Default.ArrowBack, contentDescription = &quot;Back&quot;)&#10;                        }&#10;                    },&#10;                    actions = {&#10;                        // 3-dot menu&#10;                        Box {&#10;                            IconButton(onClick = { showMenu = true }) {&#10;                                Icon(Icons.Default.MoreVert, contentDescription = &quot;More options&quot;)&#10;                            }&#10;                            DropdownMenu(&#10;                                expanded = showMenu,&#10;                                onDismissRequest = { showMenu = false }&#10;                            ) {&#10;                                DropdownMenuItem(&#10;                                    text = { Text(&quot;Edit&quot;) },&#10;                                    onClick = {&#10;                                        showMenu = false&#10;                                        // Open editor at current page&#10;                                        val intent = android.content.Intent(context, EditorActivity::class.java).apply {&#10;                                            putExtra(&quot;book_path&quot;, viewModel.getBookPath())&#10;                                            putExtra(&quot;book_title&quot;, bookTitle)&#10;                                            putExtra(&quot;initial_page&quot;, viewModel.currentPageIndex.value)&#10;                                        }&#10;                                        context.startActivity(intent)&#10;                                        activity?.finish()&#10;                                    },&#10;                                    leadingIcon = {&#10;                                        Icon(&#10;                                            Icons.Default.Edit,&#10;                                            contentDescription = null&#10;                                        )&#10;                                    }&#10;                                )&#10;                                DropdownMenuItem(&#10;                                    text = { Text(&quot;Font Size&quot;) },&#10;                                    onClick = {&#10;                                        showFontSizeDialog = true&#10;                                        showMenu = false&#10;                                    }&#10;                                )&#10;                            }&#10;                        }&#10;                    },&#10;                    colors = TopAppBarDefaults.topAppBarColors(&#10;                        containerColor = MaterialTheme.colorScheme.surface,&#10;                        scrolledContainerColor = MaterialTheme.colorScheme.surface&#10;                    )&#10;                )&#10;                Divider(color = MaterialTheme.colorScheme.outline.copy(alpha = 0.2f), thickness = 1.dp)&#10;            }&#10;        },&#10;        bottomBar = {&#10;            BookReaderControls(&#10;                onPreviousClick = { viewModel.previousPage() },&#10;                onNextClick = { viewModel.nextPage() },&#10;                onJumpToPage = { viewModel.jumpToPage(it) },&#10;                currentPage = viewModel.currentPageIndex.value,&#10;                pageCount = viewModel.pageCount.value,&#10;                isLoading = isLoading&#10;            )&#10;        },&#10;        modifier = Modifier.fillMaxSize()&#10;    ) { paddingValues -&gt;&#10;        if (isLoading) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(paddingValues),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Column(&#10;                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                    verticalArrangement = Arrangement.Center&#10;                ) {&#10;                    CircularProgressIndicator()&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                    Text(&quot;Loading page...&quot;)&#10;                }&#10;            }&#10;        } else {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(paddingValues)&#10;            ) {&#10;                RichTextReader(&#10;                    key = viewModel.currentPageIndex.value,&#10;                    content = viewModel.currentPageContent.value,&#10;                    fontSize = viewModel.fontSize.value&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun BookReaderControls(&#10;    onPreviousClick: () -&gt; Unit,&#10;    onNextClick: () -&gt; Unit,&#10;    onJumpToPage: (Int) -&gt; Unit,&#10;    currentPage: Int,&#10;    pageCount: Int,&#10;    isLoading: Boolean&#10;) {&#10;    var jumpToPageValue by remember { mutableStateOf((currentPage + 1).toString()) }&#10;    var isEditingJumpField by remember { mutableStateOf(false) }&#10;&#10;    // Update displayed page number when user navigates&#10;    LaunchedEffect(currentPage) {&#10;        if (!isEditingJumpField) {&#10;            jumpToPageValue = (currentPage + 1).toString()&#10;        }&#10;    }&#10;&#10;    Surface(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        color = MaterialTheme.colorScheme.surface,&#10;        shadowElevation = 8.dp&#10;    ) {&#10;        Column {&#10;            Divider(color = MaterialTheme.colorScheme.outline.copy(alpha = 0.2f), thickness = 1.dp)&#10;&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 16.dp, vertical = 12.dp),&#10;                verticalAlignment = Alignment.CenterVertically,&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                // Previous button&#10;                IconButton(&#10;                    onClick = onPreviousClick,&#10;                    enabled = currentPage &gt; 0,&#10;                    modifier = Modifier.size(40.dp)&#10;                ) {&#10;                    Icon(&#10;                        Icons.Default.ArrowBack,&#10;                        contentDescription = &quot;Previous Page&quot;,&#10;                        modifier = Modifier.size(20.dp)&#10;                    )&#10;                }&#10;&#10;                // Page indicator&#10;                Box(&#10;                    modifier = Modifier.weight(1f),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    if (isLoading) {&#10;                        Row(&#10;                            horizontalArrangement = Arrangement.Center,&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            CircularProgressIndicator(&#10;                                modifier = Modifier.size(16.dp),&#10;                                strokeWidth = 2.dp&#10;                            )&#10;                            Spacer(modifier = Modifier.width(8.dp))&#10;                            Text(&#10;                                &quot;Page ${currentPage + 1} of $pageCount&quot;,&#10;                                style = MaterialTheme.typography.labelMedium&#10;                            )&#10;                        }&#10;                    } else {&#10;                        Text(&#10;                            &quot;Page ${currentPage + 1} of $pageCount&quot;,&#10;                            style = MaterialTheme.typography.labelMedium&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Jump field&#10;                TextField(&#10;                    value = jumpToPageValue,&#10;                    onValueChange = {&#10;                        jumpToPageValue = it&#10;                        isEditingJumpField = it.isNotEmpty()&#10;                    },&#10;                    label = { Text(&quot;Page&quot;, style = MaterialTheme.typography.labelSmall) },&#10;                    keyboardOptions = androidx.compose.foundation.text.KeyboardOptions(&#10;                        keyboardType = androidx.compose.ui.text.input.KeyboardType.Number&#10;                    ),&#10;                    modifier = Modifier.width(70.dp).height(40.dp),&#10;                    singleLine = true,&#10;                    textStyle = MaterialTheme.typography.bodySmall,&#10;                    colors = TextFieldDefaults.colors(&#10;                        unfocusedContainerColor = MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.3f)&#10;                    )&#10;                )&#10;&#10;                // Go button&#10;                Button(&#10;                    onClick = {&#10;                        jumpToPageValue.toIntOrNull()?.let {&#10;                            if (it in 1..pageCount) {&#10;                                onJumpToPage(it - 1)&#10;                                isEditingJumpField = false&#10;                            }&#10;                        }&#10;                    },&#10;                    modifier = Modifier.height(40.dp),&#10;                    contentPadding = PaddingValues(horizontal = 12.dp)&#10;                ) {&#10;                    Text(&quot;Go&quot;, style = MaterialTheme.typography.labelSmall)&#10;                }&#10;&#10;                // Next button&#10;                IconButton(&#10;                    onClick = onNextClick,&#10;                    enabled = currentPage &lt; pageCount - 1,&#10;                    modifier = Modifier.size(40.dp)&#10;                ) {&#10;                    Icon(&#10;                        Icons.Default.ArrowForward,&#10;                        contentDescription = &quot;Next Page&quot;,&#10;                        modifier = Modifier.size(20.dp)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun FontSizeDialog(&#10;    currentSize: Int,&#10;    onDismiss: () -&gt; Unit,&#10;    onSizeSelected: (Int) -&gt; Unit&#10;) {&#10;    val fontSizes = listOf(12, 14, 16, 18, 20, 22, 24, 28, 32)&#10;&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = { Text(&quot;Font Size&quot;) },&#10;        text = {&#10;            Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {&#10;                fontSizes.forEach { size -&gt;&#10;                    TextButton(&#10;                        onClick = { onSizeSelected(size) },&#10;                        modifier = Modifier.fillMaxWidth()&#10;                    ) {&#10;                        Row(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            horizontalArrangement = Arrangement.SpaceBetween,&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Text(&quot;${size}pt&quot;, style = MaterialTheme.typography.bodyLarge)&#10;                            if (size == currentSize) {&#10;                                Text(&quot;âœ“&quot;, color = MaterialTheme.colorScheme.primary)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        },&#10;        confirmButton = {},&#10;        dismissButton = {&#10;            TextButton(onClick = onDismiss) {&#10;                Text(&quot;Cancel&quot;)&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;@SuppressLint(&quot;SetJavaScriptEnabled&quot;)&#10;@Composable&#10;fun RichTextReader(key: Int, content: String, fontSize: Int) {&#10;    var isPageLoaded by remember { mutableStateOf(false) }&#10;    var lastPageKey by remember { mutableStateOf(key) }&#10;    val webViewRef = remember { mutableStateOf&lt;WebView?&gt;(null) }&#10;&#10;    // When page changes, reload HTML&#10;    LaunchedEffect(key) {&#10;        if (lastPageKey != key) {&#10;            lastPageKey = key&#10;            isPageLoaded = false&#10;            webViewRef.value?.loadUrl(&quot;file:///android_asset/reader.html&quot;)&#10;        }&#10;    }&#10;&#10;    // When page finishes loading, set the content&#10;    LaunchedEffect(isPageLoaded, key, content) {&#10;        if (isPageLoaded &amp;&amp; content.isNotEmpty()) {&#10;            val escapedContent = org.json.JSONObject.quote(content)&#10;            webViewRef.value?.evaluateJavascript(&quot;javascript:setContent($escapedContent, $fontSize);&quot;, null)&#10;        } else if (isPageLoaded &amp;&amp; content.isEmpty()) {&#10;            // Empty page&#10;            webViewRef.value?.evaluateJavascript(&quot;javascript:setContent('', $fontSize);&quot;, null)&#10;        }&#10;    }&#10;&#10;    // Update font size when it changes&#10;    LaunchedEffect(fontSize) {&#10;        if (isPageLoaded) {&#10;            webViewRef.value?.evaluateJavascript(&quot;javascript:setFontSize($fontSize);&quot;, null)&#10;        }&#10;    }&#10;&#10;    AndroidView(&#10;        factory = { ctx -&gt;&#10;            WebView(ctx).apply {&#10;                webViewRef.value = this&#10;                settings.apply {&#10;                    javaScriptEnabled = true&#10;                    domStorageEnabled = true&#10;                }&#10;&#10;                webViewClient = object : WebViewClient() {&#10;                    override fun onPageFinished(view: WebView?, url: String?) {&#10;                        super.onPageFinished(view, url)&#10;                        isPageLoaded = true&#10;                    }&#10;                }&#10;&#10;                loadUrl(&quot;file:///android_asset/reader.html&quot;)&#10;                layoutParams = ViewGroup.LayoutParams(&#10;                    ViewGroup.LayoutParams.MATCH_PARENT,&#10;                    ViewGroup.LayoutParams.MATCH_PARENT&#10;                )&#10;            }&#10;        },&#10;        modifier = Modifier.fillMaxSize()&#10;    )&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/vuiya/bookbuddy/BookReaderViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/vuiya/bookbuddy/BookReaderViewModel.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.vuiya.bookbuddy&#10;&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;import java.io.File&#10;&#10;class BookReaderViewModel(private val bookPath: String?) : ViewModel() {&#10;    val currentPageIndex = mutableStateOf(0)&#10;    val pageCount = mutableStateOf(0)&#10;    val currentPageContent = mutableStateOf(&quot;&quot;)&#10;    val isLoading = mutableStateOf(false)&#10;    val fontSize = mutableStateOf(16)&#10;&#10;    private var pageFiles: List&lt;File&gt; = emptyList()&#10;    private val bookDirectory: File? = bookPath?.let { File(it) }&#10;&#10;    init {&#10;        loadBook()&#10;    }&#10;&#10;    private fun loadBook() {&#10;        viewModelScope.launch(Dispatchers.IO) {&#10;            bookDirectory?.let { dir -&gt;&#10;                // Load all page files, sorted by page number&#10;                pageFiles = dir.listFiles()&#10;                    ?.filter { it.name.startsWith(&quot;page_&quot;) &amp;&amp; it.name.endsWith(&quot;.txt&quot;) &amp;&amp; !it.name.endsWith(&quot;.draft.txt&quot;) }&#10;                    ?.mapNotNull { file -&gt;&#10;                        PageNumber.fromFileName(file.name)?.let { pageNum -&gt; pageNum to file }&#10;                    }&#10;                    ?.sortedBy { it.first }&#10;                    ?.map { it.second }&#10;                    ?: emptyList()&#10;&#10;                withContext(Dispatchers.Main) {&#10;                    pageCount.value = pageFiles.size&#10;                    if (pageFiles.isNotEmpty()) {&#10;                        loadPage(0)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun loadPage(index: Int) {&#10;        if (index &lt; 0 || index &gt;= pageFiles.size) return&#10;&#10;        viewModelScope.launch(Dispatchers.IO) {&#10;            withContext(Dispatchers.Main) {&#10;                isLoading.value = true&#10;            }&#10;&#10;            val content = pageFiles[index].readText()&#10;&#10;            withContext(Dispatchers.Main) {&#10;                currentPageIndex.value = index&#10;                currentPageContent.value = content&#10;                isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun nextPage() {&#10;        if (currentPageIndex.value &lt; pageFiles.size - 1) {&#10;            loadPage(currentPageIndex.value + 1)&#10;        }&#10;    }&#10;&#10;    fun previousPage() {&#10;        if (currentPageIndex.value &gt; 0) {&#10;            loadPage(currentPageIndex.value - 1)&#10;        }&#10;    }&#10;&#10;    fun jumpToPage(index: Int) {&#10;        if (index &gt;= 0 &amp;&amp; index &lt; pageFiles.size) {&#10;            loadPage(index)&#10;        }&#10;    }&#10;&#10;    fun setFontSize(size: Int) {&#10;        fontSize.value = size&#10;    }&#10;&#10;    fun getBookPath(): String? {&#10;        return bookPath&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/vuiya/bookbuddy/EditorActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/vuiya/bookbuddy/EditorActivity.kt" />
              <option name="originalContent" value="package com.vuiya.bookbuddy&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.viewModels&#10;import com.vuiya.bookbuddy.ui.theme.BookBuddyTheme&#10;&#10;class EditorActivity : ComponentActivity() {&#10;    private val viewModel: EditorViewModel by viewModels()&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        val bookPath = intent.getStringExtra(&quot;book_path&quot;)&#10;        val bookTitle = intent.getStringExtra(&quot;book_title&quot;) ?: &quot;Editor&quot;&#10;&#10;        viewModel.loadBook(bookPath)&#10;&#10;        setContent {&#10;            BookBuddyTheme {&#10;                EditorScreen(&#10;                    bookTitle = bookTitle,&#10;                    viewModel = viewModel&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onStop() {&#10;        super.onStop()&#10;        viewModel.onActivityStop()&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.vuiya.bookbuddy&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.viewModels&#10;import com.vuiya.bookbuddy.ui.theme.BookBuddyTheme&#10;&#10;class EditorActivity : ComponentActivity() {&#10;    private val viewModel: EditorViewModel by viewModels()&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        val bookPath = intent.getStringExtra(&quot;book_path&quot;)&#10;        val bookTitle = intent.getStringExtra(&quot;book_title&quot;) ?: &quot;Editor&quot;&#10;        val initialPage = intent.getIntExtra(&quot;initial_page&quot;, 0)&#10;&#10;        viewModel.loadBook(bookPath, initialPage)&#10;&#10;        setContent {&#10;            BookBuddyTheme {&#10;                EditorScreen(&#10;                    bookTitle = bookTitle,&#10;                    viewModel = viewModel&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onStop() {&#10;        super.onStop()&#10;        viewModel.onActivityStop()&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/vuiya/bookbuddy/EditorViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/vuiya/bookbuddy/EditorViewModel.kt" />
              <option name="originalContent" value="package com.vuiya.bookbuddy&#10;&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableSharedFlow&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;import java.io.File&#10;&#10;class EditorViewModel : ViewModel() {&#10;&#10;    private var pageFiles = listOf&lt;File&gt;()&#10;    private var bookDirectory: File? = null&#10;    val currentPageIndex = mutableStateOf(0)&#10;    val currentPageContent = mutableStateOf(&quot;&quot;)&#10;    val pageCount = mutableStateOf(0)&#10;    val isLoading = mutableStateOf(false)&#10;    val saveComplete = MutableSharedFlow&lt;Unit&gt;()  // Only for manual saves&#10;    private var autoSaveJob: Job? = null&#10;&#10;    fun loadBook(path: String?) {&#10;        if (path == null) return&#10;        viewModelScope.launch {&#10;            isLoading.value = true&#10;&#10;            withContext(Dispatchers.IO) {&#10;                bookDirectory = File(path)&#10;                // Create .draft marker file to indicate this book is being edited&#10;                File(bookDirectory, &quot;.draft&quot;).createNewFile()&#10;            }&#10;&#10;            pageFiles = withContext(Dispatchers.IO) {&#10;                File(path).listFiles()?.filter {&#10;                    !it.name.endsWith(&quot;.draft.txt&quot;) &amp;&amp; it.name != &quot;.draft&quot;&#10;                }?.mapNotNull { file -&gt;&#10;                    PageNumber.fromFileName(file.name)?.let { pageNum -&gt; pageNum to file }&#10;                }?.sortedBy { it.first }?.map { it.second } ?: emptyList()&#10;            }&#10;            pageCount.value = pageFiles.size&#10;&#10;            if (pageFiles.isNotEmpty()) {&#10;                jumpToPage(0)  // This will set isLoading to false after content loads&#10;            } else {&#10;                isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun onContentChanged(newContent: String) {&#10;        currentPageContent.value = newContent&#10;    }&#10;&#10;    fun saveAndNavigate(next: Boolean) {&#10;        autoSaveJob?.cancel()&#10;        viewModelScope.launch(Dispatchers.IO) {&#10;            // Save current page&#10;            saveDraft()&#10;&#10;            withContext(Dispatchers.Main) {&#10;                if (next) {&#10;                    jumpToPage(currentPageIndex.value + 1)&#10;                } else {&#10;                    jumpToPage(currentPageIndex.value - 1)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun jumpToPage(pageIndex: Int) {&#10;        if (pageIndex !in pageFiles.indices) return&#10;&#10;        autoSaveJob?.cancel()&#10;        viewModelScope.launch {&#10;            isLoading.value = true&#10;&#10;            // Save current page BEFORE changing pageIndex&#10;            withContext(Dispatchers.IO) {&#10;                saveDraft()&#10;            }&#10;&#10;            // NOW update page index&#10;            currentPageIndex.value = pageIndex&#10;&#10;            // Load new page content&#10;            withContext(Dispatchers.IO) {&#10;                val pageFile = pageFiles[pageIndex]&#10;                val draftFile = File(pageFile.parent, &quot;${pageFile.nameWithoutExtension}.draft.txt&quot;)&#10;                val contentToLoad = if (draftFile.exists()) draftFile.readText() else pageFile.readText()&#10;                withContext(Dispatchers.Main) {&#10;                    currentPageContent.value = contentToLoad&#10;                    startAutoSave()&#10;                    isLoading.value = false&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun commitCurrentPage() {&#10;        autoSaveJob?.cancel()&#10;        viewModelScope.launch(Dispatchers.IO) {&#10;            // Commit all draft files to main files&#10;            pageFiles.forEach { pageFile -&gt;&#10;                val draftFile = File(pageFile.parent, &quot;${pageFile.nameWithoutExtension}.draft.txt&quot;)&#10;                if (draftFile.exists()) {&#10;                    // Copy draft content to main file&#10;                    pageFile.writeText(draftFile.readText())&#10;                    // Delete the draft file&#10;                    draftFile.delete()&#10;                }&#10;            }&#10;&#10;            // Remove .draft marker file to mark book as published&#10;            bookDirectory?.let {&#10;                File(it, &quot;.draft&quot;).delete()&#10;            }&#10;&#10;            withContext(Dispatchers.Main) {&#10;                saveComplete.emit(Unit)  // Only emit for manual saves&#10;                startAutoSave()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun startAutoSave() {&#10;        autoSaveJob?.cancel()&#10;        autoSaveJob = viewModelScope.launch {&#10;            delay(10000)&#10;            saveDraft()  // Silent auto-save, no toast&#10;            startAutoSave()&#10;        }&#10;    }&#10;&#10;    private suspend fun saveDraft() {&#10;        withContext(Dispatchers.IO) {&#10;            val pageFile = pageFiles[currentPageIndex.value]&#10;            val draftFile = File(pageFile.parent, &quot;${pageFile.nameWithoutExtension}.draft.txt&quot;)&#10;            draftFile.writeText(currentPageContent.value)&#10;        }&#10;    }&#10;&#10;    fun onActivityStop() {&#10;        autoSaveJob?.cancel()&#10;        viewModelScope.launch(Dispatchers.IO) {&#10;            saveDraft()&#10;        }&#10;    }&#10;&#10;    fun addNewPage() {&#10;        autoSaveJob?.cancel()&#10;        viewModelScope.launch(Dispatchers.IO) {&#10;            // Save current page first&#10;            saveDraft()&#10;&#10;            // Get the last page number and increment&#10;            val lastPageNumber = if (pageFiles.isNotEmpty()) {&#10;                PageNumber.fromFileName(pageFiles.last().name) ?: PageNumber(&quot;0&quot;)&#10;            } else {&#10;                PageNumber(&quot;0&quot;)&#10;            }&#10;            val newPageNumber = lastPageNumber.next()&#10;&#10;            // Create new page file&#10;            val newPageFile = File(bookDirectory, PageNumber.toFileName(newPageNumber))&#10;            newPageFile.writeText(&quot;&quot;)&#10;&#10;            // Reload page files list with proper sorting&#10;            pageFiles = bookDirectory?.listFiles()?.filter {&#10;                !it.name.endsWith(&quot;.draft.txt&quot;) &amp;&amp; it.name != &quot;.draft&quot;&#10;            }?.mapNotNull { file -&gt;&#10;                PageNumber.fromFileName(file.name)?.let { pageNum -&gt; pageNum to file }&#10;            }?.sortedBy { it.first }?.map { it.second } ?: emptyList()&#10;&#10;            withContext(Dispatchers.Main) {&#10;                pageCount.value = pageFiles.size&#10;                // Jump to the new page&#10;                jumpToPage(pageFiles.size - 1)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Inserts a new page after the current page&#10;     * Example: current page is 1, creates 1.1&#10;     */&#10;    fun insertPageAfter() {&#10;        autoSaveJob?.cancel()&#10;        viewModelScope.launch(Dispatchers.IO) {&#10;            // Save current page first&#10;            saveDraft()&#10;&#10;            if (pageFiles.isEmpty()) {&#10;                // If no pages, create page 1&#10;                val newPageFile = File(bookDirectory, &quot;page_1.txt&quot;)&#10;                newPageFile.writeText(&quot;&quot;)&#10;            } else {&#10;                // Get current page number and create sub-page&#10;                val currentPageFile = pageFiles[currentPageIndex.value]&#10;                val currentPageNumber = PageNumber.fromFileName(currentPageFile.name) ?: PageNumber(&quot;1&quot;)&#10;                val newPageNumber = currentPageNumber.insertAfter()&#10;&#10;                // Create new page file&#10;                val newPageFile = File(bookDirectory, PageNumber.toFileName(newPageNumber))&#10;                newPageFile.writeText(&quot;&quot;)&#10;            }&#10;&#10;            // Reload page files list with proper sorting&#10;            pageFiles = bookDirectory?.listFiles()?.filter {&#10;                !it.name.endsWith(&quot;.draft.txt&quot;) &amp;&amp; it.name != &quot;.draft&quot;&#10;            }?.mapNotNull { file -&gt;&#10;                PageNumber.fromFileName(file.name)?.let { pageNum -&gt; pageNum to file }&#10;            }?.sortedBy { it.first }?.map { it.second } ?: emptyList()&#10;&#10;            withContext(Dispatchers.Main) {&#10;                pageCount.value = pageFiles.size&#10;                // Jump to the newly inserted page (right after current)&#10;                jumpToPage(currentPageIndex.value + 1)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Inserts a new page before the current page&#10;     * Example: if current page is 2, finds the previous page (1 or 1.x) and inserts between them&#10;     */&#10;    fun insertPageBefore() {&#10;        autoSaveJob?.cancel()&#10;        viewModelScope.launch(Dispatchers.IO) {&#10;            // Save current page first&#10;            saveDraft()&#10;&#10;            if (pageFiles.isEmpty()) {&#10;                // If no pages, create page 1&#10;                val newPageFile = File(bookDirectory, &quot;page_1.txt&quot;)&#10;                newPageFile.writeText(&quot;&quot;)&#10;            } else if (currentPageIndex.value == 0) {&#10;                // If we're on the first page, create a page before it&#10;                val firstPageFile = pageFiles[0]&#10;                val firstPageNumber = PageNumber.fromFileName(firstPageFile.name) ?: PageNumber(&quot;1&quot;)&#10;&#10;                // Create 0.9 or similar page number that comes before&#10;                val parts = firstPageNumber.value.split(&quot;.&quot;)&#10;                val newPageNumber = if (parts.size == 1) {&#10;                    // If it's a whole number like &quot;1&quot;, create &quot;0.9&quot;&#10;                    PageNumber(&quot;0.9&quot;)&#10;                } else {&#10;                    // If it's like &quot;1.1&quot;, create a page just before it&#10;                    val lastPart = parts.last().toIntOrNull() ?: 1&#10;                    val prefix = parts.dropLast(1).joinToString(&quot;.&quot;)&#10;                    PageNumber(&quot;$prefix.${lastPart - 1}.9&quot;)&#10;                }&#10;&#10;                val newPageFile = File(bookDirectory, PageNumber.toFileName(newPageNumber))&#10;                newPageFile.writeText(&quot;&quot;)&#10;            } else {&#10;                // Get previous page number and insert after it&#10;                val previousPageFile = pageFiles[currentPageIndex.value - 1]&#10;                val previousPageNumber = PageNumber.fromFileName(previousPageFile.name) ?: PageNumber(&quot;1&quot;)&#10;                val newPageNumber = previousPageNumber.insertAfter()&#10;&#10;                // Create new page file&#10;                val newPageFile = File(bookDirectory, PageNumber.toFileName(newPageNumber))&#10;                newPageFile.writeText(&quot;&quot;)&#10;            }&#10;&#10;            // Reload page files list with proper sorting&#10;            pageFiles = bookDirectory?.listFiles()?.filter {&#10;                !it.name.endsWith(&quot;.draft.txt&quot;) &amp;&amp; it.name != &quot;.draft&quot;&#10;            }?.mapNotNull { file -&gt;&#10;                PageNumber.fromFileName(file.name)?.let { pageNum -&gt; pageNum to file }&#10;            }?.sortedBy { it.first }?.map { it.second } ?: emptyList()&#10;&#10;            withContext(Dispatchers.Main) {&#10;                pageCount.value = pageFiles.size&#10;                // Stay on the same logical position (which is now index + 1 because we inserted before)&#10;                jumpToPage(currentPageIndex.value)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Exports the book to a publishable format&#10;     */&#10;    fun exportBook(format: ExportFormat, context: android.content.Context) {&#10;        viewModelScope.launch(Dispatchers.IO) {&#10;            try {&#10;                bookDirectory?.let { dir -&gt;&#10;                    val exporter = BookExporter(context)&#10;                    val bookTitle = dir.name&#10;                    val downloadsDir = android.os.Environment.getExternalStoragePublicDirectory(&#10;                        android.os.Environment.DIRECTORY_DOWNLOADS&#10;                    )&#10;                    val outputFile = File(downloadsDir, &quot;$bookTitle.${format.extension}&quot;)&#10;&#10;                    when (format) {&#10;                        ExportFormat.PLAIN_TEXT -&gt; exporter.exportToPlainText(dir, outputFile)&#10;                        ExportFormat.MARKDOWN -&gt; exporter.exportToMarkdown(dir, outputFile)&#10;                        ExportFormat.HTML -&gt; exporter.exportToCleanHtml(dir, outputFile, bookTitle, &quot;Unknown Author&quot;)&#10;                    }&#10;&#10;                    withContext(Dispatchers.Main) {&#10;                        android.widget.Toast.makeText(&#10;                            context,&#10;                            &quot;Exported to: ${outputFile.absolutePath}&quot;,&#10;                            android.widget.Toast.LENGTH_LONG&#10;                        ).show()&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                withContext(Dispatchers.Main) {&#10;                    android.widget.Toast.makeText(&#10;                        context,&#10;                        &quot;Export failed: ${e.message}&quot;,&#10;                        android.widget.Toast.LENGTH_LONG&#10;                    ).show()&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.vuiya.bookbuddy&#10;&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableSharedFlow&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;import java.io.File&#10;&#10;class EditorViewModel : ViewModel() {&#10;&#10;    private var pageFiles = listOf&lt;File&gt;()&#10;    private var bookDirectory: File? = null&#10;    val currentPageIndex = mutableStateOf(0)&#10;    val currentPageContent = mutableStateOf(&quot;&quot;)&#10;    val pageCount = mutableStateOf(0)&#10;    val isLoading = mutableStateOf(false)&#10;    val saveComplete = MutableSharedFlow&lt;Unit&gt;()  // Only for manual saves&#10;    private var autoSaveJob: Job? = null&#10;&#10;    fun loadBook(path: String?, initialPage: Int = 0) {&#10;        if (path == null) return&#10;        viewModelScope.launch {&#10;            isLoading.value = true&#10;&#10;            withContext(Dispatchers.IO) {&#10;                bookDirectory = File(path)&#10;                // Create .draft marker file to indicate this book is being edited&#10;                File(bookDirectory, &quot;.draft&quot;).createNewFile()&#10;            }&#10;&#10;            pageFiles = withContext(Dispatchers.IO) {&#10;                File(path).listFiles()?.filter {&#10;                    !it.name.endsWith(&quot;.draft.txt&quot;) &amp;&amp; it.name != &quot;.draft&quot;&#10;                }?.mapNotNull { file -&gt;&#10;                    PageNumber.fromFileName(file.name)?.let { pageNum -&gt; pageNum to file }&#10;                }?.sortedBy { it.first }?.map { it.second } ?: emptyList()&#10;            }&#10;            pageCount.value = pageFiles.size&#10;&#10;            if (pageFiles.isNotEmpty()) {&#10;                // Jump to the specified initial page (from reader) or page 0&#10;                val targetPage = initialPage.coerceIn(0, pageFiles.size - 1)&#10;                jumpToPage(targetPage)  // This will set isLoading to false after content loads&#10;            } else {&#10;                isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun onContentChanged(newContent: String) {&#10;        currentPageContent.value = newContent&#10;    }&#10;&#10;    fun saveAndNavigate(next: Boolean) {&#10;        autoSaveJob?.cancel()&#10;        viewModelScope.launch(Dispatchers.IO) {&#10;            // Save current page&#10;            saveDraft()&#10;&#10;            withContext(Dispatchers.Main) {&#10;                if (next) {&#10;                    jumpToPage(currentPageIndex.value + 1)&#10;                } else {&#10;                    jumpToPage(currentPageIndex.value - 1)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun jumpToPage(pageIndex: Int) {&#10;        if (pageIndex !in pageFiles.indices) return&#10;&#10;        autoSaveJob?.cancel()&#10;        viewModelScope.launch {&#10;            isLoading.value = true&#10;&#10;            // Save current page BEFORE changing pageIndex&#10;            withContext(Dispatchers.IO) {&#10;                saveDraft()&#10;            }&#10;&#10;            // NOW update page index&#10;            currentPageIndex.value = pageIndex&#10;&#10;            // Load new page content&#10;            withContext(Dispatchers.IO) {&#10;                val pageFile = pageFiles[pageIndex]&#10;                val draftFile = File(pageFile.parent, &quot;${pageFile.nameWithoutExtension}.draft.txt&quot;)&#10;                val contentToLoad = if (draftFile.exists()) draftFile.readText() else pageFile.readText()&#10;                withContext(Dispatchers.Main) {&#10;                    currentPageContent.value = contentToLoad&#10;                    startAutoSave()&#10;                    isLoading.value = false&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun commitCurrentPage() {&#10;        autoSaveJob?.cancel()&#10;        viewModelScope.launch(Dispatchers.IO) {&#10;            // Commit all draft files to main files&#10;            pageFiles.forEach { pageFile -&gt;&#10;                val draftFile = File(pageFile.parent, &quot;${pageFile.nameWithoutExtension}.draft.txt&quot;)&#10;                if (draftFile.exists()) {&#10;                    // Copy draft content to main file&#10;                    pageFile.writeText(draftFile.readText())&#10;                    // Delete the draft file&#10;                    draftFile.delete()&#10;                }&#10;            }&#10;&#10;            // Remove .draft marker file to mark book as published&#10;            bookDirectory?.let {&#10;                File(it, &quot;.draft&quot;).delete()&#10;            }&#10;&#10;            withContext(Dispatchers.Main) {&#10;                saveComplete.emit(Unit)  // Only emit for manual saves&#10;                startAutoSave()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun startAutoSave() {&#10;        autoSaveJob?.cancel()&#10;        autoSaveJob = viewModelScope.launch {&#10;            delay(10000)&#10;            saveDraft()  // Silent auto-save, no toast&#10;            startAutoSave()&#10;        }&#10;    }&#10;&#10;    private suspend fun saveDraft() {&#10;        withContext(Dispatchers.IO) {&#10;            val pageFile = pageFiles[currentPageIndex.value]&#10;            val draftFile = File(pageFile.parent, &quot;${pageFile.nameWithoutExtension}.draft.txt&quot;)&#10;            draftFile.writeText(currentPageContent.value)&#10;        }&#10;    }&#10;&#10;    fun onActivityStop() {&#10;        autoSaveJob?.cancel()&#10;        viewModelScope.launch(Dispatchers.IO) {&#10;            saveDraft()&#10;        }&#10;    }&#10;&#10;    fun addNewPage() {&#10;        autoSaveJob?.cancel()&#10;        viewModelScope.launch(Dispatchers.IO) {&#10;            // Save current page first&#10;            saveDraft()&#10;&#10;            // Get the last page number and increment&#10;            val lastPageNumber = if (pageFiles.isNotEmpty()) {&#10;                PageNumber.fromFileName(pageFiles.last().name) ?: PageNumber(&quot;0&quot;)&#10;            } else {&#10;                PageNumber(&quot;0&quot;)&#10;            }&#10;            val newPageNumber = lastPageNumber.next()&#10;&#10;            // Create new page file&#10;            val newPageFile = File(bookDirectory, PageNumber.toFileName(newPageNumber))&#10;            newPageFile.writeText(&quot;&quot;)&#10;&#10;            // Reload page files list with proper sorting&#10;            pageFiles = bookDirectory?.listFiles()?.filter {&#10;                !it.name.endsWith(&quot;.draft.txt&quot;) &amp;&amp; it.name != &quot;.draft&quot;&#10;            }?.mapNotNull { file -&gt;&#10;                PageNumber.fromFileName(file.name)?.let { pageNum -&gt; pageNum to file }&#10;            }?.sortedBy { it.first }?.map { it.second } ?: emptyList()&#10;&#10;            withContext(Dispatchers.Main) {&#10;                pageCount.value = pageFiles.size&#10;                // Jump to the new page&#10;                jumpToPage(pageFiles.size - 1)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Inserts a new page after the current page&#10;     * Example: current page is 1, creates 1.1&#10;     */&#10;    fun insertPageAfter() {&#10;        autoSaveJob?.cancel()&#10;        viewModelScope.launch(Dispatchers.IO) {&#10;            // Save current page first&#10;            saveDraft()&#10;&#10;            if (pageFiles.isEmpty()) {&#10;                // If no pages, create page 1&#10;                val newPageFile = File(bookDirectory, &quot;page_1.txt&quot;)&#10;                newPageFile.writeText(&quot;&quot;)&#10;            } else {&#10;                // Get current page number and create sub-page&#10;                val currentPageFile = pageFiles[currentPageIndex.value]&#10;                val currentPageNumber = PageNumber.fromFileName(currentPageFile.name) ?: PageNumber(&quot;1&quot;)&#10;                val newPageNumber = currentPageNumber.insertAfter()&#10;&#10;                // Create new page file&#10;                val newPageFile = File(bookDirectory, PageNumber.toFileName(newPageNumber))&#10;                newPageFile.writeText(&quot;&quot;)&#10;            }&#10;&#10;            // Reload page files list with proper sorting&#10;            pageFiles = bookDirectory?.listFiles()?.filter {&#10;                !it.name.endsWith(&quot;.draft.txt&quot;) &amp;&amp; it.name != &quot;.draft&quot;&#10;            }?.mapNotNull { file -&gt;&#10;                PageNumber.fromFileName(file.name)?.let { pageNum -&gt; pageNum to file }&#10;            }?.sortedBy { it.first }?.map { it.second } ?: emptyList()&#10;&#10;            withContext(Dispatchers.Main) {&#10;                pageCount.value = pageFiles.size&#10;                // Jump to the newly inserted page (right after current)&#10;                jumpToPage(currentPageIndex.value + 1)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Inserts a new page before the current page&#10;     * Example: if current page is 2, finds the previous page (1 or 1.x) and inserts between them&#10;     */&#10;    fun insertPageBefore() {&#10;        autoSaveJob?.cancel()&#10;        viewModelScope.launch(Dispatchers.IO) {&#10;            // Save current page first&#10;            saveDraft()&#10;&#10;            if (pageFiles.isEmpty()) {&#10;                // If no pages, create page 1&#10;                val newPageFile = File(bookDirectory, &quot;page_1.txt&quot;)&#10;                newPageFile.writeText(&quot;&quot;)&#10;            } else if (currentPageIndex.value == 0) {&#10;                // If we're on the first page, create a page before it&#10;                val firstPageFile = pageFiles[0]&#10;                val firstPageNumber = PageNumber.fromFileName(firstPageFile.name) ?: PageNumber(&quot;1&quot;)&#10;&#10;                // Create 0.9 or similar page number that comes before&#10;                val parts = firstPageNumber.value.split(&quot;.&quot;)&#10;                val newPageNumber = if (parts.size == 1) {&#10;                    // If it's a whole number like &quot;1&quot;, create &quot;0.9&quot;&#10;                    PageNumber(&quot;0.9&quot;)&#10;                } else {&#10;                    // If it's like &quot;1.1&quot;, create a page just before it&#10;                    val lastPart = parts.last().toIntOrNull() ?: 1&#10;                    val prefix = parts.dropLast(1).joinToString(&quot;.&quot;)&#10;                    PageNumber(&quot;$prefix.${lastPart - 1}.9&quot;)&#10;                }&#10;&#10;                val newPageFile = File(bookDirectory, PageNumber.toFileName(newPageNumber))&#10;                newPageFile.writeText(&quot;&quot;)&#10;            } else {&#10;                // Get previous page number and insert after it&#10;                val previousPageFile = pageFiles[currentPageIndex.value - 1]&#10;                val previousPageNumber = PageNumber.fromFileName(previousPageFile.name) ?: PageNumber(&quot;1&quot;)&#10;                val newPageNumber = previousPageNumber.insertAfter()&#10;&#10;                // Create new page file&#10;                val newPageFile = File(bookDirectory, PageNumber.toFileName(newPageNumber))&#10;                newPageFile.writeText(&quot;&quot;)&#10;            }&#10;&#10;            // Reload page files list with proper sorting&#10;            pageFiles = bookDirectory?.listFiles()?.filter {&#10;                !it.name.endsWith(&quot;.draft.txt&quot;) &amp;&amp; it.name != &quot;.draft&quot;&#10;            }?.mapNotNull { file -&gt;&#10;                PageNumber.fromFileName(file.name)?.let { pageNum -&gt; pageNum to file }&#10;            }?.sortedBy { it.first }?.map { it.second } ?: emptyList()&#10;&#10;            withContext(Dispatchers.Main) {&#10;                pageCount.value = pageFiles.size&#10;                // Stay on the same logical position (which is now index + 1 because we inserted before)&#10;                jumpToPage(currentPageIndex.value)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Exports the book to a publishable format&#10;     */&#10;    fun exportBook(format: ExportFormat, context: android.content.Context) {&#10;        viewModelScope.launch(Dispatchers.IO) {&#10;            try {&#10;                bookDirectory?.let { dir -&gt;&#10;                    val exporter = BookExporter(context)&#10;                    val bookTitle = dir.name&#10;                    val downloadsDir = android.os.Environment.getExternalStoragePublicDirectory(&#10;                        android.os.Environment.DIRECTORY_DOWNLOADS&#10;                    )&#10;                    val outputFile = File(downloadsDir, &quot;$bookTitle.${format.extension}&quot;)&#10;&#10;                    when (format) {&#10;                        ExportFormat.PLAIN_TEXT -&gt; exporter.exportToPlainText(dir, outputFile)&#10;                        ExportFormat.MARKDOWN -&gt; exporter.exportToMarkdown(dir, outputFile)&#10;                        ExportFormat.HTML -&gt; exporter.exportToCleanHtml(dir, outputFile, bookTitle, &quot;Unknown Author&quot;)&#10;                    }&#10;&#10;                    withContext(Dispatchers.Main) {&#10;                        android.widget.Toast.makeText(&#10;                            context,&#10;                            &quot;Exported to: ${outputFile.absolutePath}&quot;,&#10;                            android.widget.Toast.LENGTH_LONG&#10;                        ).show()&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                withContext(Dispatchers.Main) {&#10;                    android.widget.Toast.makeText(&#10;                        context,&#10;                        &quot;Export failed: ${e.message}&quot;,&#10;                        android.widget.Toast.LENGTH_LONG&#10;                    ).show()&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/vuiya/bookbuddy/LibraryActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/vuiya/bookbuddy/LibraryActivity.kt" />
              <option name="originalContent" value="package com.vuiya.bookbuddy&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.mutableStateListOf&#10;import androidx.compose.runtime.remember&#10;import com.vuiya.bookbuddy.ui.theme.BookBuddyTheme&#10;import java.io.File&#10;&#10;class LibraryActivity : ComponentActivity() {&#10;    private var libraryItems: MutableList&lt;LibraryItem&gt;? = null&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        displayLibrary()&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        // Refresh library list when returning from editor&#10;        libraryItems?.let { loadLibraryItems(it) }&#10;        // Redraw UI with refreshed items&#10;        displayLibrary()&#10;    }&#10;&#10;    private fun displayLibrary() {&#10;        setContent {&#10;            val items = remember {&#10;                libraryItems ?: mutableStateListOf&lt;LibraryItem&gt;().also { libraryItems = it }&#10;            }&#10;&#10;            BookBuddyTheme {&#10;                LibraryScreen(&#10;                    libraryItems = items,&#10;                    onRemoveItem = { book -&gt;&#10;                        items.remove(book)&#10;                        book.filePath?.let { File(it).deleteRecursively() }&#10;                    },&#10;                    onOpenBook = { book -&gt;&#10;                        val intent = Intent(this@LibraryActivity, ReaderActivity::class.java).apply {&#10;                            putExtra(&quot;book_path&quot;, book.filePath)&#10;                            putExtra(&quot;book_title&quot;, book.title)&#10;                        }&#10;                        startActivity(intent)&#10;                    },&#10;                    onPublishBook = { book -&gt;&#10;                        book.filePath?.let { path -&gt;&#10;                            File(path, &quot;.draft&quot;).delete()&#10;                            book.category = &quot;Book&quot;&#10;                        }&#10;                    },&#10;                    onCreateBook = { title, author, language -&gt;&#10;                        createNewBook(title, author, language)&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun loadLibraryItems(items: MutableList&lt;LibraryItem&gt;) {&#10;        items.clear()&#10;        val libraryDir = File(filesDir, &quot;library&quot;)&#10;        if (!libraryDir.exists()) {&#10;            libraryDir.mkdirs()&#10;        }&#10;        val books = libraryDir.listFiles()?.filter { it.isDirectory }?.map {&#10;            val isDraft = File(it, &quot;.draft&quot;).exists()&#10;            LibraryItem(it.name, &quot;Unknown Author&quot;, &quot;English&quot;, if (isDraft) &quot;Draft&quot; else &quot;Book&quot;, it.absolutePath)&#10;        } ?: emptyList()&#10;        items.addAll(books)&#10;    }&#10;&#10;    private fun createNewBook(title: String, author: String, language: String) {&#10;        val libraryDir = File(filesDir, &quot;library&quot;)&#10;        if (!libraryDir.exists()) {&#10;            libraryDir.mkdirs()&#10;        }&#10;&#10;        // Create book directory&#10;        val bookDir = File(libraryDir, title)&#10;        if (bookDir.exists()) {&#10;            // If book with same name exists, append a number&#10;            var counter = 1&#10;            var uniqueBookDir = File(libraryDir, &quot;$title ($counter)&quot;)&#10;            while (uniqueBookDir.exists()) {&#10;                counter++&#10;                uniqueBookDir = File(libraryDir, &quot;$title ($counter)&quot;)&#10;            }&#10;            uniqueBookDir.mkdirs()&#10;            createInitialPage(uniqueBookDir)&#10;            openBookInEditor(uniqueBookDir.absolutePath, uniqueBookDir.name)&#10;        } else {&#10;            bookDir.mkdirs()&#10;            createInitialPage(bookDir)&#10;            openBookInEditor(bookDir.absolutePath, title)&#10;        }&#10;    }&#10;&#10;    private fun createInitialPage(bookDir: File) {&#10;        // Create first blank page&#10;        val page0 = File(bookDir, &quot;page_0.txt&quot;)&#10;        page0.writeText(&quot;&quot;)&#10;    }&#10;&#10;    private fun openBookInEditor(bookPath: String, bookTitle: String) {&#10;        val intent = Intent(this, EditorActivity::class.java).apply {&#10;            putExtra(&quot;book_path&quot;, bookPath)&#10;            putExtra(&quot;book_title&quot;, bookTitle)&#10;        }&#10;        startActivity(intent)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.vuiya.bookbuddy&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateListOf&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import com.vuiya.bookbuddy.ui.theme.BookBuddyTheme&#10;import java.io.File&#10;&#10;class LibraryActivity : ComponentActivity() {&#10;    private var refreshTrigger = mutableStateOf(0)&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContent {&#10;            val items = remember { mutableStateListOf&lt;LibraryItem&gt;() }&#10;            val trigger by refreshTrigger&#10;&#10;            // Reload items whenever trigger changes&#10;            LaunchedEffect(trigger) {&#10;                loadLibraryItems(items)&#10;            }&#10;&#10;            BookBuddyTheme {&#10;                LibraryScreen(&#10;                    libraryItems = items,&#10;                    onRemoveItem = { book -&gt;&#10;                        items.remove(book)&#10;                        book.filePath?.let { File(it).deleteRecursively() }&#10;                    },&#10;                    onOpenBook = { book -&gt;&#10;                        // Open published books in BookReaderActivity, drafts in EditorActivity&#10;                        val intent = if (book.category == &quot;Draft&quot;) {&#10;                            Intent(this@LibraryActivity, EditorActivity::class.java).apply {&#10;                                putExtra(&quot;book_path&quot;, book.filePath)&#10;                                putExtra(&quot;book_title&quot;, book.title)&#10;                            }&#10;                        } else {&#10;                            Intent(this@LibraryActivity, BookReaderActivity::class.java).apply {&#10;                                putExtra(&quot;book_path&quot;, book.filePath)&#10;                                putExtra(&quot;book_title&quot;, book.title)&#10;                            }&#10;                        }&#10;                        startActivity(intent)&#10;                    },&#10;                    onPublishBook = { book -&gt;&#10;                        book.filePath?.let { path -&gt;&#10;                            File(path, &quot;.draft&quot;).delete()&#10;                            book.category = &quot;Book&quot;&#10;                            // Reload library to reflect changes&#10;                            loadLibraryItems(items)&#10;                        }&#10;                    },&#10;                    onCreateBook = { title, author, language -&gt;&#10;                        createNewBook(title, author, language)&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        // Trigger a refresh by incrementing the counter&#10;        refreshTrigger.value++&#10;    }&#10;&#10;    private fun loadLibraryItems(items: MutableList&lt;LibraryItem&gt;) {&#10;        items.clear()&#10;        val libraryDir = File(filesDir, &quot;library&quot;)&#10;        if (!libraryDir.exists()) {&#10;            libraryDir.mkdirs()&#10;        }&#10;        val books = libraryDir.listFiles()?.filter { it.isDirectory }?.map {&#10;            val isDraft = File(it, &quot;.draft&quot;).exists()&#10;            LibraryItem(it.name, &quot;Unknown Author&quot;, &quot;English&quot;, if (isDraft) &quot;Draft&quot; else &quot;Book&quot;, it.absolutePath)&#10;        } ?: emptyList()&#10;        items.addAll(books)&#10;    }&#10;&#10;    private fun createNewBook(title: String, author: String, language: String) {&#10;        val libraryDir = File(filesDir, &quot;library&quot;)&#10;        if (!libraryDir.exists()) {&#10;            libraryDir.mkdirs()&#10;        }&#10;&#10;        // Create book directory&#10;        val bookDir = File(libraryDir, title)&#10;        if (bookDir.exists()) {&#10;            // If book with same name exists, append a number&#10;            var counter = 1&#10;            var uniqueBookDir = File(libraryDir, &quot;$title ($counter)&quot;)&#10;            while (uniqueBookDir.exists()) {&#10;                counter++&#10;                uniqueBookDir = File(libraryDir, &quot;$title ($counter)&quot;)&#10;            }&#10;            uniqueBookDir.mkdirs()&#10;            createInitialPage(uniqueBookDir)&#10;            openBookInEditor(uniqueBookDir.absolutePath, uniqueBookDir.name)&#10;        } else {&#10;            bookDir.mkdirs()&#10;            createInitialPage(bookDir)&#10;            openBookInEditor(bookDir.absolutePath, title)&#10;        }&#10;    }&#10;&#10;    private fun createInitialPage(bookDir: File) {&#10;        // Create first page with proper numbering (page_1.txt)&#10;        val page1 = File(bookDir, &quot;page_1.txt&quot;)&#10;        page1.writeText(&quot;&quot;)&#10;&#10;        // Mark as draft&#10;        File(bookDir, &quot;.draft&quot;).createNewFile()&#10;    }&#10;&#10;    private fun openBookInEditor(bookPath: String, bookTitle: String) {&#10;        val intent = Intent(this, EditorActivity::class.java).apply {&#10;            putExtra(&quot;book_path&quot;, bookPath)&#10;            putExtra(&quot;book_title&quot;, bookTitle)&#10;        }&#10;        startActivity(intent)&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>